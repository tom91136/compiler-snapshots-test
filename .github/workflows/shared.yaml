name: Generate snapshots

on:
  workflow_call:
    inputs:
      config:
        required: true
        type: string
      build_script:
        required: true
        type: string

# Just give up if we have a new commit
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  build_container:
    strategy:
      matrix:
        os: [ubuntu-24.04, ubuntu-24.04-arm]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4

      - name: Restore cached image
        id: restore-image
        uses: actions/cache@v4
        with:
          path: /tmp/build_image.tar
          key: ${{ hashFiles('Dockerfile') }}-${{ matrix.os }}

      - name: Set up Docker Buildx
        if: steps.restore-image.outputs.cache-hit != 'true'
        uses: docker/setup-buildx-action@v2

      - name: Build and export
        if: steps.restore-image.outputs.cache-hit != 'true'
        uses: docker/build-push-action@v3
        with:
          context: .
          tags: build_image:latest
          outputs: type=docker,dest=/tmp/build_image.tar

  compute_builds:
    runs-on: ubuntu-24.04
    outputs:
      matrix: ${{ steps.set-builds.outputs.builds }}
    steps:
      - uses: actions/checkout@v4

      - name: Install sbt
        uses: sbt/setup-sbt@v1

      - name: Compute required builds
        run: sbt "project generator; run ${{ inputs.config }} $GITHUB_REPOSITORY"

      - name: Show builds
        run: |
          jq . matrix-${{ inputs.config }}.json
          jq . builds-${{ inputs.config }}.json

      - name: Set output
        id: set-builds
        run: echo "builds=$(cat matrix-${{ inputs.config }}.json)" >> $GITHUB_OUTPUT
        # run: |
        #   builds=$(jq -c '.[-30:]' matrix-${{ inputs.config }}.json)
        #   echo "builds=$builds" >> $GITHUB_OUTPUT

      - name: Save build artefact
        uses: actions/upload-artifact@v4
        with:
          name: builds
          path: builds-${{ inputs.config }}.json

  build:
    needs: [compute_builds, build_container]
    if: ${{ needs.compute_builds.outputs.matrix != '[]' && needs.compute_builds.outputs.matrix != '' }}
    strategy:
      fail-fast: false # don't give up too early
      matrix:
        os: [ubuntu-24.04, ubuntu-24.04-arm]
        jobs: ${{ fromJson(needs.compute_builds.outputs.matrix) }}
    runs-on: ${{ matrix.os }}
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - name: Restore cached image
        id: restore-image
        uses: actions/cache@v4
        with:
          path: /tmp/build_image.tar
          key: ${{ hashFiles('Dockerfile') }}-${{ matrix.os }}

      - name: Restore build artefact
        uses: actions/download-artifact@v5
        with:
          name: builds

      - name: Discard build config name
        run: mv builds-${{ inputs.config }}.json builds.json

      - name: Load image
        run: docker load --input /tmp/build_image.tar

      - name: Create persistent image
        run: docker create --name "build_persistent" -v "$PWD:/host" build_image:latest sleep infinity

      - name: Build & create releases
        env:
          JOBS: ${{ matrix.jobs }}
          BUILD_SCRIPT: ${{ inputs.build_script }}
          TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -uo pipefail  # no -e: keep going
          IFS=';' read -r -a jobs <<< "$JOBS"
          failed=false
          summary=()

          host_arch="$(uname -m)"

          fmt_time() { date -ud "@$1" +'%Hh%Mm%Ss'; }

          docker start "build_persistent" >/dev/null

          for job in "${jobs[@]}"; do
            [[ -z "$job" ]] && continue

            job_arch="${job##*.}"
            if [[ "$job_arch" != "$host_arch" ]]; then
              echo "Skipping $job (arch mismatch: host=$host_arch, job=$job_arch)"
              continue
            fi

            echo "::group::Build $job"
            SECONDS=0
            if timeout 6h docker exec -w "/host" build_persistent "/host/$BUILD_SCRIPT" "$job"; then
              echo "::endgroup::"
              echo "::group::Release $job"
              summary+=("✅ \`$job (build,   $(fmt_time "$SECONDS"))\`")
              SECONDS=0
              if ./action_create_release.sh "$TOKEN" "$job"; then
                echo "Release for $job done."
                summary+=("✅ \`$job (release, $(fmt_time "$SECONDS"))\`")
              else
                echo "Release for $job FAILED." >&2
                summary+=("❌ \`$job (release, $(fmt_time "$SECONDS"))\`")
                failed=true
              fi
              echo "::endgroup::"
            else
              echo "::endgroup::"
              echo "Build for $job FAILED — skipping release." >&2
              summary+=("❌ \`$job (build,   $(fmt_time "$SECONDS"))\`")
              failed=true
            fi
          done

          { for line in "${summary[@]}"; do printf '%s\n' "$line"; done; } | tee -a "$GITHUB_STEP_SUMMARY"

          if [ "$failed" = true ]; then
            echo "::error::One or more builds failed" && exit 1
          fi
